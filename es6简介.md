# ES6 简介#

**参考资料**

[ES6入门 阮一峰](http://es6.ruanyifeng.com/ "ES6入门 阮一峰")

ES6中的js语法更新，更多应用场景是在node端，对于前端来说，最主要的就是新增了**promise**、**Symbol**、**Class语法的原生支持**、**es6 module的支持**、**变量的解构赋值**、**let和const**，然后就是一些引用对象新增了一些方法调用。

## let 和 const ##

let 和 var一样，都是用来声明变量的，但是var声明，因为存在作用域提升的问题，不像传统的编程语言那样具有块级作用域，所以很容易出现变量提升带来的问题，最常见的就是for循环计数器输出全部都是最后一位数。

而let，因为引入了块级作用域，所以其声明的变量只在其代码块内有效。自然也就不存在变量提升了。

const 则是声明一个只读常量，一旦声明该变量所指向的内存地址就不可更改。所以当声明的是一个基本类型时，就是不可更改的，而引用类型只是一个内存指针，所以实际指向的内容可以变化。

更多细节，请查看 [es6 let和const](http://es6.ruanyifeng.com/#docs/let "es6 let和const")

## 变量的解构赋值 ##

在ES6还未诞生的时候，对象或方法之间的参数赋值和解析，一般都是避不开的。但是鉴于这类操作频繁发生，所以解构赋值这一特性在es6中，理所当然的成为了规范的一部分。

何为解构赋值？

> ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构

以下是例子：

    let a = 1
	let b = 2
	let c = 3

	在ES6中，可以写成这样

	let [a, b,b c] = [1, 2, 3]

更多细节，请查看 [es6 解构赋值](http://es6.ruanyifeng.com/#docs/destructuring "es6 解构赋值")


## Promise ##

promise部分的知识，如果要全部讲完，甚至可以出一本薄书。在此只讲最基础的语法部分，具体场景应用部分不会提及。

在es6之前，js的异步编程解决方案就是**事件和回调函数**，但是事件回调机制，存在一个问题，如果很多操作都是要等待异步完成后再去执行，势必代码会形成一层套一层的结构，既不利于编写，也不利于理清逻辑。

所以es6的promise就诞生了，它是一个容器，保存着一个异步操作，当异步操作完成后，会改变状态，通知容器去处理。状态有三种：pending（进行中），fulfilled（已成功），rejected（已失败）。只有当pending变为fulfilled或rejected，状态才会固定下来，之后都不会发生改变。
与事件不同的是，事件如果已经发生了，再添加监听，会拿不到结果。但是promise只要声明，状态固定后就会一直存在，任何时候对promise添加回调处理，都可以拿到操作的结果。

根据这种特性，所以promise的回调是`then`方法里进行成功执行的回调，而在`catch`里执行错误异常的回调。很适合jquery那种的链式调用写法，所以代码的可维护性更强，逻辑也更加清晰。避免了事件监听的回调地狱。

### 原型方法 ###

1. then
2. catch
3. finally
4. all
5. race
6. resolve
7. reject
8. try

更多细节，请查看 [es6 Promise](http://es6.ruanyifeng.com/#docs/promise "es6 Promise")


## Class ##


js本身并没有面向对象的写法，只能通过原型链的方式去模拟构造面向对象的方式。但是es6中，通过Class这一大多数面向对象语言都支持的类声明，把es5的原型继承包装了，给了一个看似支持面向对象的语法糖，其本质还是es5的原型继承。

更多细节，请查看 [es6 Class](http://es6.ruanyifeng.com/#docs/class "es6 Class")

## ES6 module ##

ES6没有采用AMD和CommonJS规范，而是自成一系，良好的兼容了浏览器环境和服务区环境的模块加载方案。

采用import、export的语法对模块进行管理，

更多细节，请查看 [es6 Module](http://es6.ruanyifeng.com/#docs/module "es6 Module")


### 当然ES6的新特性远不止这些，但是对于日常开发使用，知道这些便足够，如果想要更加深入的学习，更多特性将在node端大放光彩，适合结合node的学习一并深入 ###